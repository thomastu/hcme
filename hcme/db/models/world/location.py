import sqlalchemy as sa
from geoalchemy2 import Geometry

from hcme.db import Base


class Location(Base):

    __tablename__ = "locations"

    parcel_id = sa.Column(sa.String, unique=True, nullable=False)

    coordinates = sa.Column(
        Geometry("POINT", spatial_index=False, srid=4326), nullable=False
    )

    use = sa.Column(sa.String(50), nullable=False, index=True)

    parcel_type = sa.Column(sa.String(50), nullable=False)

    zone_type = sa.Column(sa.String(50), nullable=True)

    residential = sa.Column(sa.Boolean, nullable=False, index=True)

    city = sa.Column(sa.String(50), nullable=False, index=True)

    zipcode = sa.Column(sa.String(5), nullable=False)

    # Weighting for selection.  For residential parcels, this will represent liklihood
    # of selection.  For commercial parcels, will represent liklihood of trip destination.
    weight = sa.Column(sa.Float, nullable=False, default=1)

    # USPS Designation
    carrier_route_description = sa.Column(sa.String(50), nullable=True)

    carrier_route_id = sa.Column(sa.String(10), nullable=True)

    valid_delivery_area = sa.Column(sa.Boolean, nullable=False, default=False)

    # Foreign keys
    taz_id = sa.Column(sa.Integer, sa.ForeignKey("tazs.id"), nullable=False)

    census_block_geoid = sa.Column(
        sa.String, sa.ForeignKey("census_block.id"), nullable=False
    )

    __table_args__ = (
        # Create an index for use and parcel_type
        sa.Index("ix_locations_use_parcel_type", use, parcel_type),
        # Unique constraint on parcel_id and taz_id
        sa.UniqueConstraint(
            "parcel_id", "taz_id", name="uq_locations_parcel_id_taz_id"
        ),
    )


# Manually override the spatial index to ensure alembic auto-migrations do
# not delete postGIS autogenerated indices
sa.Index("locations_coordinates_gist", Location.coordinates, postgresql_using="gist")
